https://pastebin.com/KdRsRLTt

USE tvshow

SELECT * FROM Show
SELECT * FROM Episode
SELECT * FROM Actor
SELECT * FROM ShowStar
SELECT * FROM ShowStarGuest

-- 1. Да се модифицира базата от данни, така че да може да се съхранява иформация за звезди-гости,
-- които са актьори, поканени да участват в конкретен епизод на сериала. Да се изберат адекватни
-- ограничения за създадената таблица/таблици.
CREATE TABLE ShowStarGuest (
	ShowID int NOT NULL, 
    ActorID int NOT NULL REFERENCES Actor(ActorID),
	Season int NOT NULL,
    Episode int NOT NULL,
	FOREIGN KEY(ShowID,Season,Episode) REFERENCES Episode(ShowID, Season, Episode),
	Plays varchar(64),
	PRIMARY KEY(ShowID,ActorID,Season,Episode)
)

---------------------------------------------------------------------------------------------------------

-- 2. Да се добави като звезда гост George Clooney, които играе Dr. Mitchell в епизод 17 на
-- сезон 1 на сериала Friends
INSERT INTO Actor (FirstName, LastName) VALUES ('George', 'Clooney')
INSERT INTO ShowStarGuest VALUES (1,@@IDENTITY,1,17,'Dr. Mitchell')

---------------------------------------------------------------------------------------------------------

-- 3. Да се направи така, че да не се допуска въвеждане на сериали на език различен от английски, в случай,
-- че телевизията, която го поръчва е NBC или FOX.
ALTER TABLE Show
ADD CONSTRAINT language_valid CHECK ((Television like 'NBC' or Television like 'FOX') AND (Language like 'English'))
	
INSERT INTO Show VALUES (
    'Friends2',
    'Hilarious sitcom for adults and older teens. Follows the personal and professional lives of six 20 to 30-something-year-old friends living in Manhattan.',
    'Comedy',
    'French',
    'Warner Bros. Television',
    'NBC',
    'USA',
    13,
    8.9,
    3,
    1,
    3,
    2,
    NULL,
    3)

---------------------------------------------------------------------------------------------------------

--4
-- 4. Една от най-често използваните заявки от приложение, което работи с базата е със следната структурата
-- показана по-долу (стойностите за дата се задават от потребители да приложението).
-- Какво бихте направили, за да ускорите изпълнението на подобни заявки в базата, в която вече има съхранена
-- информация за десетки хиляди сериали и епизоди?
 
--SELECT ShowTitle, Title AS EpisodeTitle
--FROM Show s
--   JOIN Episode e ON s.ShowID = e.ShowID
--WHERE e.DateAired = '1994-11-17'
 
-- Създайте обектите, които са нужни със съответния SQL скрипт.
CREATE INDEX EpisodeDateAired ON Episode(DateAired)--tove e indeks po DateAired
select * from EpisodeDateAired

---------------------------------------------------------------------------------------------------------

-- 5. Кое би помогнало за ускоряването на заявката по-долу:
 
-- а) клъстеризиран индекс по ShowTitle
-- b) клъстеризиран индекс по Title
-- c) клъстеризиран индекс по (ShowTitle, Title)
-- d) клъстеризиран индекс по (Title, ShowTitle)
-- е) неклъстеризиран индекс по ShowTitle
-- f) неклъстеризиран индекс по Title
-- g) неклъстеризиран индекс по (ShowTitle, Title)
-- h) неклъстеризиран индекс по (Title, ShowTitle)
 
--SELECT ShowTitle, Title AS EpisodeTitle
--FROM Show s
--    JOIN Episode e ON s.ShowID = e.ShowID
--WHERE e.Title LIKE '%Evil%'
--GO

--Отговор: Никое, защото всичките клъстери подреждат по азбучен ред, а ние не знаем с какво започва нашия e.Title, защото първият търсен символ е % в '%Evil%'
--Ако имахме някакъв конкретен символ, вместо %, отговорът щеше да е неклъстеризиран индекс  по Title

---------------------------------------------------------------------------------------------------------

-- 6. Да се направи така, че да не е възможно звездите от основния каст, които участват в даден сериал,
-- да бъдат добавяни като звезди гости за епизоди на сериала.

--ALTER TABLE ShowStarGuest
--ADD CONSTRAINT regular_actor CHECK (ActorID not in (SELECT ss.ActorID FROM Actor ss WHERE ss.ActorID=ActorID))   HE!!!!!!!!!!!!!!!

GO
CREATE TRIGGER TrgAfterActorIsAddedAsGuestStar ON ShowStarGuest AFTER INSERT, UPDATE
AS
	IF(EXISTS (SELECT * FROM inserted JOIN ShowStar ss ON inserted.ShowID=ss.ShowId))
	BEGIN 
		ROLLBACK
	END
GO

INSERT INTO Actor (FirstName, LastName) VALUES ('David', 'Schwimmer')
--INSERT INTO ShowStar VALUES (1, @@IDENTITY, 'Chandler Bing')
INSERT INTO ShowStarGuest VALUES (1,@@IDENTITY,1,17,'Dr. Mitchell') --гърми, защото се е задействал тригерът

--бонус задача: Да добавим property EpisodeCount int в Show с DEFAULT 0. Да създадем тригер, който 
--при добавяне или махане на епизод за даден сериал да поддържа този EpisodeCount
ALTER TABLE Show ADD EpisodeCount int default 0

--игнорираме тая задача :D

---------------------------------------------------------------------------------------------------------

-- 7. Таблиците Person и Teacher имат следната структура:
 
-- CREATE TABLE Person (                 CREATE TABLE Teacher (
--    egn char(10),                         egn char(10),
--    name varchar(128),                    university varchar(64)
--    address varchar(128)               );
-- );
 
-- С кои от изброените средства може да се направи така, че един човек да не може да бъде преподавател
-- в повече от един университет?
 
-- a. чрез AFTER INSERT/UPDATE тригер за таблицата Person
-- b. чрез PRIMARY KEY ограничение за двойката колони university и egn в таблицата Teacher
-- c. чрез INSTEAD OF INSERT/UPDATE тригер за таблицата Person
-- d. чрез FOREIGN KEY ограничение в таблицата Person
-- e. чрез PRIMARY KEY ограничение за колоната university в таблицата Teacher
-- f. чрез UNIQUE ограничение за колоната university в таблицата Teacher
-- g. чрез INSTEAD OF INSERT/UPDATE тригер за таблицата Teacher
-- h. чрез CHECK ограничение за колоната university в таблицата Teacher
-- i. чрез UNIQUE ограничение за двойката колони university и egn в таблицата Teacher
-- j. чрез AFTER INSERT/UPDATE тригер за таблицата Teacher
-- k. чрез FOREIGN KEY ограничение в таблицата Teacher

--Отговор: всички такива неща може с тригер, не може с foreign key и check constraint-и, така че: g, j

---------------------------------------------------------------------------------------------------------
 
-- 8. В таблицата Person от предната задача има 10 милиона записа. Създаваме уникален индекс
-- по колоната egn. Кои заявки ще се ускорят?
--  
-- a. SELECT * FROM Person WHERE egn = '9106192093'
-- b. SELECT egn FROM Person WHERE egn = '9106192093'
-- c. SELECT egn, name FROM Person WHERE egn = '9106192093'
-- d. SELECT * FROM Person
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')
-- e. SELECT egn FROM Person
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')
-- f. SELECT egn, name FROM Person
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')
-- g. UPDATE Person SET egn = '9106192834' WHERE egn = '9106192093'
-- h. UPDATE Person SET egn = '9106192834'
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')
-- i. UPDATE Person SET name = 'Petar Petrov' WHERE egn = '9106192093'
-- j. UPDATE Person SET name = 'Petar Petrov'
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')
-- k. DELETE FROM Person WHERE egn = '9106192093'
-- l. DELETE FROM Person
--        WHERE egn IN ('9106192093', '9211218273', '9201218172', '9205091923', '6802012938')

-- Отговор: Всичко се ускорява.
 
---------------------------------------------------------------------------------------------------------
 
-- 9. Кои тип данни е удачно да се използва за колона, която трябва да може да съхранява текст,
-- чиято дължина е от 1000 до 7000 латински символа?
 
-- a. char(1000)
-- b. char(7000)
-- c. varchar(1000)
-- d. varchar(7000)

-- Отговор: d

---------------------------------------------------------------------------------------------------------
 
-- 10. Кои от следните твърдения са верни?
 
-- a. Индексите ускоряват заявки, в чиито WHERE клаузи се съдържат условия от вида col LIKE '%word%'.
-- b. При добавяне на ограничение UNIQUE автоматично се създава клъстериран индекс.
-- c. При създаване на индекс може да се посочи повече от една колона и редът на колоните е от значение.
-- d. За дадена таблица може да има само един клъстеризиран индекс
-- е. Една от разликите межди таблици и изгледи е, че за изгледите немогат да се създават индекси.

-- Отговор: c, d
 
---------------------------------------------------------------------------------------------------------
 
-- 11. Кой от следните типове данни е най-подходящ за колона, съхраняваща цена на продукт?
 
-- a. CHAR(6)
-- b. DECIMAL(6, 2)
-- c. FLOAT
-- d. INT

-- Отговор: b
 
---------------------------------------------------------------------------------------------------------
 
-- 12. Кои от следните твърдения са верни?
 
-- a. При създаване на PRIMARY KEY ограничение, автоматично се създава неклъстериран индекс.
-- b. За да се ускори една SELECT заявка, в нея трябва изрично да е указано кои индекси да се използват.
-- c. Наличието на индекс върху колона col ще ускори изпълнението на SELECT заявка, съдържаща ORDER BY col.
-- d. Клъстеризиран индекс е добре да се създава след създаването неклъстеризираните индекси. ->oбратното е вярно

-- Отговор: c
 
---------------------------------------------------------------------------------------------------------
 
-- 13. Кои от следните твърдения са верни?
 
-- a. Ако искаме в една таблица да има първичен ключ, съставен от две колони, пишем PRIMARY KEY срещу всяка
--    от тях (напр. title VARCHAR(50) PRIMARY KEY, year INT PRIMARY KEY).
-- b. Първичен ключ, съставен от две колони, допуска във всяка от двете колони да има повторения, стига да
--    няма два реда, при които стойностите и за двете колони да съвпадат
-- c. Външният ключ не позволява NULL стойности, но позволява повторения //ако сочи към колона, която поддържа UNIQUE NULL стойности е вярно
-- d. Външният ключ трябва да реферира към колона, за която има дефинирано PRIMARY KEY или UNIQUE ограничение

-- Отговор: b, d
 
---------------------------------------------------------------------------------------------------------
 
-- 14. Кои твърдения са грешни?
 
-- a. върху изгледи може да се дефинират само INSTEAD OF тригери
-- b. AFTER DELETE тригерите не могат да отказват изтриването на редове в таблицата, за която са дефинирани
-- c. таблиците inserted и deleted са достъпни както в AFTER, така и в INSTEAD OF тригерите
-- d. върху таблици могат да се дефинират само AFTER тригери
-- e. таблицата inserted е винаги празна в тялото на AFTER UPDATE тригер

-- Отговор: b, d, e
 
---------------------------------------------------------------------------------------------------------
 
-- 15. Искаме клетките в дадена колона да не могат да приемат стойност NULL. Кои от следните средства не са
--    приложими за целта?
 
-- a. DEFAULT стойност
-- b. PRIMARY KEY
-- c. NOT NULL ограничение
-- d. AFTER тригер
-- e. INSTEAD OF тригер
-- f. CHECK ограничение

-- Отговор: a
 
---------------------------------------------------------------------------------------------------------
 
-- 16. Искаме при изтриване на клас автоматично да се изтриват и всички негови кораби. Кое не е приложимо
--     за целта?
 
-- a. AFTER тригер
-- b. INSTEAD OF тригер
-- c. политика ON DELETE CASCADE върху външния ключ
-- d. политика ON UPDATE CASCADE върху външния ключ

-- Отговор: d
 
---------------------------------------------------------------------------------------------------------